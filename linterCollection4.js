const express = require("express");
const multer = require("multer");
const fs = require("fs");
const path = require("path");
const bodyParser = require("body-parser");

const app = express();
const PORT = 3000;
const upload = multer({ dest: "uploads/" });

app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));
app.use(express.static("public"));
app.use(bodyParser.urlencoded({ extended: true }));

const autoGeneratedHeaders = [
    "content-type", "user-agent", "accept", "cache-control", "postman-token",
    "host", "accept-encoding", "connection"
];

const isAlreadyProcessed = (collection) => collection.info?.name.includes("_Version");

// ðŸ“Œ Fonction pour extraire lâ€™URI sans `baseUrl`
const extractRequestName = (item) => {
    if (item.request && item.request.url) {
        if (item.request.url.raw.includes("{{baseUrl}}")) {
            return item.request.url.raw.replace("{{baseUrl}}", "").trim();
        } else {
            try {
                const urlObject = new URL(item.request.url.raw);
                return `${urlObject.pathname}${urlObject.search}`.trim();
            } catch (error) {
                return item.name; // En cas d'erreur, garder le nom initial
            }
        }
    }
    return item.name;
};

// ðŸ“Œ GÃ©nÃ©ration de tests pour les champs JSON des rÃ©ponses
const generateResponseTests = (responseBody, customTests = [], requestName) => {
    const tests = [];
    let parsedBody;

    try {
        parsedBody = JSON.parse(responseBody || '{}');
    } catch (e) {
        console.warn("Impossible de parser la rÃ©ponse en JSON. IgnorÃ©.");
        return tests;
    }

    Object.keys(parsedBody).forEach((key) => {
        tests.push(`pm.test("[${requestName}] - La rÃ©ponse contient '${key}'", function () {`);
        tests.push(`    pm.expect(pm.response.json()).to.have.property('${key}');`);
        tests.push("});");
    });

    customTests.forEach(test => tests.push(test));
    return tests;
};

// ðŸ“Œ Ajout de tests Ã  une requÃªte
const addTestsToRequest = (item, expectedStatusCode, responseBody, customTests = []) => {
    if (!item.event) item.event = [];
    let testEvent = item.event.find((e) => e.listen === "test");

    if (!testEvent) {
        testEvent = { listen: "test", script: { exec: [], type: "text/javascript", packages: {} } };
        item.event.push(testEvent);
    }

    const scriptExec = testEvent.script.exec;
    const requestName = extractRequestName(item);

    if (!scriptExec.some(line => line.includes(`pm.test("[${requestName}] - Statut HTTP recherchÃ©`))) {
        scriptExec.push(
            `pm.test("[${requestName}] - Statut HTTP recherchÃ©: ${expectedStatusCode}", function () {`,
            `    pm.response.to.have.status(${expectedStatusCode});`,
            `});`
        );
    }

    if (!scriptExec.some(line => line.includes(`pm.test("[${requestName}] - Temps de rÃ©ponse raisonnable`))) {
        scriptExec.push(
            `pm.test("[${requestName}] - Temps de rÃ©ponse raisonnable", function () {`,
            `    pm.expect(pm.response.responseTime).to.be.below(1000);`,
            `});`
        );
    }

    generateResponseTests(responseBody, customTests, requestName).forEach(test => {
        if (!scriptExec.includes(test)) scriptExec.push(test);
    });
};

// ðŸ“Œ Variabilisation des en-tÃªtes non gÃ©nÃ©rÃ©s automatiquement par Postman
const processHeaders = (headers, collectionVariables) => {
    headers.forEach(header => {
        if (!autoGeneratedHeaders.includes(header.key.toLowerCase())) {
            const variableName = header.key.toUpperCase().replace(/-/g, "_");
            const variableReference = `{{${variableName}}}`;

            if (!collectionVariables.some(v => v.key === variableName)) {
                collectionVariables.push({ key: variableName, value: header.value });
            }

            header.value = variableReference;
        }
    });
};

// ðŸ“Œ Traitement des requÃªtes et duplication en fonction des rÃ©ponses
const processItems = (items, concatNames, collectionVariables, customTests) => {
    const updatedItems = [];

    items.forEach((item) => {
        if (item.item && Array.isArray(item.item)) {
            item.item = processItems(item.item, concatNames, collectionVariables, customTests);
            updatedItems.push(item);
        } else if (item.request) {
            if (item.request.header) processHeaders(item.request.header, collectionVariables);

            if (item.request.url && item.request.url.raw.includes("http")) {
                const urlObject = new URL(item.request.url.raw);
                item.request.url.raw = `{{baseUrl}}${urlObject.pathname}${urlObject.search}`;
                item.request.url.host = ["{{baseUrl}}"];
            }

            if (item.response && Array.isArray(item.response)) {
                item.response.forEach((responseExample) => {
                    const newItem = JSON.parse(JSON.stringify(item));

                    // ðŸ“Œ VÃ©rification de l'option concatNames avant de modifier le nom
                    newItem.name = concatNames
                        ? `${extractRequestName(item)} - ${responseExample.name || 'RÃ©ponse'}`
                        : extractRequestName(item);

                    newItem.response = [responseExample];
                    const statusCode = responseExample.code || 200;
                    addTestsToRequest(newItem, statusCode, responseExample.body, customTests);
                    updatedItems.push(newItem);
                });
            } else {
                item.name = extractRequestName(item);
                updatedItems.push(item);
            }
        }
    });

    return updatedItems;
};

// ðŸ“Œ Modification de la collection Postman
const modifyCollection = (data, version, customTests = [], concatNames = false) => {
    try {
        let collection = JSON.parse(data);
        if (isAlreadyProcessed(collection)) throw new Error("Fichier dÃ©jÃ  optimisÃ©.");

        const originalName = collection.info?.name || "Collection";
        const newCollectionName = `${originalName}_${version}`;

        if (collection.info) {
            collection.info.name = newCollectionName;
            collection.info.description = `version=${version} - ${collection.info.description || "Description non fournie."}`;
        }

        collection.variable = collection.variable?.filter(v => v.key !== "baseUrl") || [];
        const collectionVariables = collection.variable || [];

        collection.item = processItems(collection.item, concatNames, collectionVariables, customTests);
        collection.variable = collectionVariables;

        return { jsonData: JSON.stringify(collection, null, 2), newCollectionName };
    } catch (error) {
        throw new Error(error.message);
    }
};

// ðŸ“Œ Routes Express
app.get("/", (req, res) => res.render("index3", { message: null, error: null }));

app.post("/upload", upload.single("postmanCollection"), (req, res) => {
    if (!req.file) return res.render("index3", { message: "Aucun fichier tÃ©lÃ©chargÃ© !", error: null });

    const version = req.body.version || "Non spÃ©cifiÃ©e";
    const customTests = req.body.customTests ? req.body.customTests.split("\n").filter(test => test.trim() !== "") : [];
    const concatNames = req.body.concatNames === 'on';
    const filePath = req.file.path;

    fs.readFile(filePath, "utf8", (err, data) => {
        if (err) return res.render("index3", { message: null, error: "Erreur lors de la lecture du fichier." });

        try {
            const { jsonData, newCollectionName } = modifyCollection(data, version, customTests, concatNames);
            const outputFilePath = path.join(__dirname, `${newCollectionName}.json`);

            fs.writeFileSync(outputFilePath, jsonData, "utf8");

            res.download(outputFilePath, `${newCollectionName}.json`, () => {
                fs.unlinkSync(filePath);
                fs.unlinkSync(outputFilePath);
            });
        } catch (error) {
            res.render("index3", { message: null, error: `Erreur : ${error.message}` });
        }
    });
});

app.listen(PORT, () => console.log(`âœ… Serveur en ligne sur http://localhost:${PORT}`));